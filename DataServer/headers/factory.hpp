/* @Author : Kartik kalaghatagi

This class receives the events generated by clients and serve the requests accordingly

*/

#include"../../common/headers/hparser.hpp"


using HttpParser=__HTTP_PARSER__::HttpParser;
class Factory
{
    char *buffer;
    int *serverFD;
    int *eventFd;
    struct epoll_event* event;
    struct epoll_event* events;
    bool *stopFactory;
    DataServer *object;
    map<string,int> mapper;


public:
    Factory(int *eFd,int *sFd,struct epoll_event *ev,struct epoll_event **evs,bool* stopFact,DataServer *o)
    {
        eventFd=eFd;
        serverFD=sFd;
        event=ev;
        events=*evs;
        stopFactory=stopFact;
        object=o;
        buffer=(char *)malloc(65535*sizeof(char));
        init();
        if(buffer==NULL)
            exit(-1);
    }

    ~Factory()
    {
        free(buffer);
    }

    void handleEvents(int,int);
    void serveRequest(int );

private:
    void init();


};

void Factory::init()
{
    mapper["dataserver"]=1;
    mapper["scheduler"]=2;
    mapper["logs"]=3;
    mapper["searchscheduler"]=4;
    mapper["shutdown"]=5;
    return;
}

void Factory::handleEvents(int i,int n)
{
    struct sockaddr clientAddr;
    socklen_t clientLen=sizeof(clientAddr);
    int clientFd,reuse=1,flag;
    for(i;i<n;i++)
    {
        if((events[i].events & EPOLLERR) || (events[i].events & EPOLLHUP) || !(events[i].events & EPOLLIN))
        {
            cout<<"epoll error";
            close(events[i].data.fd);
        }
        else if(events[i].data.fd==*serverFD)
        {
            bool acceptConnection=true;
            do // accept the new connections
            {
                clientFd=accept(*serverFD,&clientAddr,&clientLen);
                if(clientFd==-1 && (errno==EAGAIN || errno==EWOULDBLOCK))
                {
                    acceptConnection=false;
                }
                else
                {
                    setsockopt(clientFd,SOL_SOCKET,SO_REUSEPORT,&reuse,sizeof(reuse));
                    flag=fcntl(clientFd,F_GETFL,0);
                    fcntl(clientFd,F_SETFL,flag);

                    (*event).data.fd=clientFd;
                    (*event).events=EPOLLIN;

                    // add client to event listener
                    if(epoll_ctl(*eventFd,EPOLL_CTL_ADD,clientFd,event)==-1)
                    {
                        cout<<"Failed to add client to event listener "<<errno<<"\n";
                    }
                }

            }while(acceptConnection==true);
        }
        else
        {
            serveRequest(events[i].data.fd);
        }
    }
}



void Factory::serveRequest(int fd)
{
    HttpParser *hp;
    bool closeConnection=false;
    string data;

    int nBytes=read(fd,buffer,65535);
    if(nBytes==-1)
    {
        if(errno!=EAGAIN)
            close(fd);
        return;
    }
    else if(nBytes==0)
    {
        close(fd);
        return;
    }
    else
    {
        buffer[nBytes+1]='\0';
        hp=new HttpParser(buffer);
        bool is_json=true;
        // Experimental
        // Next to use std::map with function ptr to call functions
        string sendData;
        int cnt=0;
        int choice=mapper[hp->filePath];
        switch(choice)
        {
            case 1  :sendData=object->statusInfo();
                    break;
            case 2  :try
                    {
                        cout<<"Fetching link info\n";
                        if(hp->issetGET("count"))
                        {
                            cnt=stoi(hp->_GET("count"));
                        }
                    }
                    catch(std::invalid_argument &e)
                    {
                        cnt=10;
                    }
                    cnt--;
                    sendData=object->que->statusInfo(hp->issetGET("showlinks"),cnt);
                    break;
            case 3  :   {
                            stringstream ss;ss<<"logs/"<<hp->_GET("name")<<".log";
                            ifstream in(ss.str());
                            if(in.is_open()==false)
                                return;
                            string send((std::istreambuf_iterator<char>(in) ),(std::istreambuf_iterator<char>()));
                            sendData=send;
                            in.close();
                        }
                    break;
            case 4  :sendData=object->que->searchQueue(hp->_GET("url"),hp->issetGET("similar"));
                    break;
            case 5  :object->shutdown(); *stopFactory=true;
                    break;
            default : is_json=false;
                    ifstream in("www/index.html");
                    if(in.is_open()==false)
                        return;
                    string send((std::istreambuf_iterator<char>(in) ),(std::istreambuf_iterator<char>()));
                    sendData=send;
                    in.close();
        }

        if(is_json==true)
        {
            sprintf(buffer,"HTTP/1.1 200 OK\n"
                            "Server: HttpServer\n"
                            "Content-Type: text/json\n"
                            "Content-Length: %ld\n"
                            "Accept-Ranges: bytes\n"
                            "Connection: close\n"
                            "\n"
                            "%s",sendData.length(),sendData.c_str());
        }
        else
        {
            sprintf(buffer,"HTTP/1.1 200 OK\n"
                                "Server: HttpServer\n"
                                "Content-Type: text/html\n"
                                "Content-Length: %ld\n"
                                "Accept-Ranges: bytes\n"
                                "Connection: close\n"
                                "\n"
                                "%s",sendData.length(),sendData.c_str());
        }
        write(fd,buffer,strlen(buffer));

        delete hp;
    }
    return;
}

